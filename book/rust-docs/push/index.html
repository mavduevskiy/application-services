<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rust Push Component"><meta name="keywords" content="rust, rustlang, rust-lang, push"><title>push - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../push/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate push</p><div class="block version"><p>Version 0.1.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all push's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class="location"></p><div id="sidebar-vars" data-name="push" data-ty="mod" data-relpath="../"></div></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="">push</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/push/lib.rs.html#5-563" title="goto source code">[src]</a></span></h1><div class="docblock"><h1 id="rust-push-component" class="section-header"><a href="#rust-push-component">Rust Push Component</a></h1>
<p>This component helps an application to manage <a href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API">WebPush</a> subscriptions,
acting as an intermediary between Mozilla’s <a href="https://autopush.readthedocs.io/en/latest/">autopush service</a>
and platform native push infrastructure such as <a href="https://firebase.google.com/docs/cloud-messaging">Firebase Cloud Messaging</a> or <a href="https://developer.amazon.com/docs/adm/overview.html">Amazon Device Messaging</a>.</p>
<h2 id="background-concepts" class="section-header"><a href="#background-concepts">Background Concepts</a></h2><h3 id="webpush-subscriptions" class="section-header"><a href="#webpush-subscriptions">WebPush Subscriptions</a></h3>
<p>A WebPush client manages a number of <em>subscriptions</em>, each of which is used to deliver push
notifications to a different part of the app. For example, a web browser might manage a separate
subscription for each website that has registered a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">service worker</a>, and an application that includes Firefox Accounts would manage
a dedicated subscription on which to receive account state updates.</p>
<p>Each subscription is identified by a unique <em>channel id</em>, which is a randomly-generated identifier.
It’s the responsibility of the application to know how to map a channel id to an appropriate function
in the app to receive push notifications. Subscriptions also have an associated <em>scope</em> which is something
to do which service workers that your humble author doesn’t really understand :-/.</p>
<p>When a subscription is created for a channel id, we allocate <em>subscription info</em> consisting of:</p>
<ul>
<li>An HTTP endpoint URL at which push messages can be submitted.</li>
<li>A cryptographic key and authentication secret with which push messages can be encrypted.</li>
</ul>
<p>This subscription info is distributed to other services that want to send push messages to
the application.</p>
<p>The HTTP endpoint is provided by Mozilla’s <a href="https://autopush.readthedocs.io/en/latest/">autopush service</a>,
and we use the <a href="https://github.com/mozilla/rust-ece">rust-ece</a> to manage encryption with the cryptographic keys.</p>
<p>Here’s a helpful diagram of how the <em>subscription</em> flow works at a high level across the moving parts:
<img src="https://mozilla.github.io/application-services/book/diagrams/Push-Component-Subscription-flow.png" alt="A Sequence diagram showing how the different parts of push interact" title="Sequence diagram" /></p>
<h3 id="autopush-bridging" class="section-header"><a href="#autopush-bridging">AutoPush Bridging</a></h3>
<p>Our target consumer platforms each have their own proprietary push-notification infrastructure,
such as <a href="https://firebase.google.com/docs/cloud-messaging">Firebase Cloud Messaging</a> for Android
and the <a href="https://developer.apple.com/notifications/">Apple Push Notification Service</a> for iOS.
Mozilla’s <a href="https://autopush.readthedocs.io/en/latest/">autopush service</a> provides a bridge between
these different mechanisms and the WebPush standard so that they can be used with a consistent
interface.</p>
<p>This component acts a client of the <a href="https://autopush.readthedocs.io/en/latest/http.html#push-service-bridge-http-interface">Push Service Bridge HTTP Interface</a>.</p>
<p>We assume two things about the consuming application:</p>
<ul>
<li>It has registered with the autopush service and received a unique <code>app_id</code> identifying this registration.</li>
<li>It has registred with whatever platform-specific notification infrastructure is appropriate, and is
able to obtain a <code>token</code> corresponding to its native push notification state.</li>
</ul>
<p>On first use, this component will register itself as an <em>application instance</em> with the autopush service, providing the <code>app_id</code> and <code>token</code> and receiving a unique <code>uaid</code> (“user-agent id”) to identify its
connection to the server.</p>
<p>As the application adds or removes subscriptions using the API of this component, it will:</p>
<ul>
<li>Manage a local database of subscriptions and the corresponding cryptographic material.</li>
<li>Make corresponding HTTP API calls to update the state associated with its <code>uaid</code> on the autopush server.</li>
</ul>
<p>Periodically, the application should call a special <code>verify_connection</code> method to check whether
the state on the autopush server matches the local state and take any corrective action if it
differs.</p>
<p>For local development and debugging, it is possible to run a local instance of the autopush
bridge service; see <a href="https://docs.google.com/document/d/18L_g2hIj_1mncF978A_SHXN4udDQLut5P_ZHYZEwGP8">this google doc</a> for details.</p>
<h2 id="api" class="section-header"><a href="#api">API</a></h2><h2 id="initialization" class="section-header"><a href="#initialization">Initialization</a></h2>
<p>Calls are handled by the <code>PushManager</code>, which provides a handle for future calls.</p>
<p>example:</p>
<pre><code class="language-kotlin">
import mozilla.appservices.push.(PushManager, BridgeTypes)

// The following are mock calls for fetching application level configuration options.
// &quot;SenderID&quot; is the native OS push message application identifier. See Native
// messaging documentation for details.
val sender_id = SystemConfigurationOptions.get(&quot;SenderID&quot;)

// The &quot;bridge type&quot; is the identifier for the native OS push message system.
// (e.g. FCM for Google Firebase Cloud Messaging, ADM for Amazon Direct Messaging,
// etc.)
val bridge_type = BridgeTypes.FCM

// The &quot;registration_id&quot; is the native OS push message user registration number.
// Native push message registration usually happens at application start, and returns
// an opaque user identifier string. See Native messaging documentation for details.
val registration_id = NativeMessagingSystem.register(sender_id)

val push_manager = PushManager(
    sender_id,
    bridge_type,
    registration_id
)

// It is strongly encouraged that the connection is verified at least once a day.
// This will ensure that the server and UA have matching information regarding
// subscriptions. This call usually returns quickly, but may take longer if the
// UA has a large number of subscriptions and things have fallen out of sync.

for change in push_manager.verify_connection() {
    // fetch the subscriber from storage using the change[0] and
    // notify them with a `pushsubscriptionchange` message containing the new
    // endpoint change[1]
}

</code></pre>
<h2 id="new-subscription" class="section-header"><a href="#new-subscription">New subscription</a></h2>
<p>Before messages can be delivered, a new subscription must be requested. The subscription info block contains all the information a remote subscription provider service will need to encrypt and transmit a message to this user agent.</p>
<p>example:</p>
<pre><code class="language-kotlin">
// Each new request must have a unique &quot;channel&quot; identifier. This channel helps
// later identify recipients and aid in routing. A ChannelID is a UUID4 value.
// the &quot;scope&quot; is the ServiceWorkerRegistration scope. This will be used
// later for push notification management.
val channelID = GUID.randomUUID()

val subscription_info = push_manager.subscribe(channelID, endpoint_scope)

// the published subscription info has the following JSON format:
// {&quot;endpoint&quot;: subscription_info.endpoint,
//  &quot;keys&quot;: {
//      &quot;auth&quot;: subscription_info.keys.auth,
//      &quot;p256dh&quot;: subscription_info.keys.p256dh
//  }}
</code></pre>
<h2 id="end-a-subscription" class="section-header"><a href="#end-a-subscription">End a subscription</a></h2>
<p>A user may decide to no longer receive a given subscription. To remove a given subscription, pass the associated channelID</p>
<pre><code class="language-kotlin">push_manager.unsubscribe(channelID)  // Terminate a single subscription
</code></pre>
<p>If the user wishes to terminate all subscriptions, send and empty string for channelID</p>
<pre><code class="language-kotlin">push_manager.unsubscribe(&quot;&quot;)        // Terminate all subscriptions for a user
</code></pre>
<p>If this function returns <code>false</code> the subsequent <code>verify_connection</code> may result in new channel endpoints.</p>
<h2 id="decrypt-an-incoming-subscription-message" class="section-header"><a href="#decrypt-an-incoming-subscription-message">Decrypt an incoming subscription message</a></h2>
<p>An incoming subscription body will contain a number of metadata elements along with the body of the message. Due to platform differences, how that metadata is provided may //! vary, however the most common form is that the messages “payload” looks like.</p>
<pre><code class="language-javascript">{&quot;chid&quot;: &quot;...&quot;,         // ChannelID
 &quot;con&quot;: &quot;...&quot;,          // Encoding form
 &quot;enc&quot;: &quot;...&quot;,          // Optional encryption header
 &quot;crypto-key&quot;: &quot;...&quot;,   // Optional crypto key header
 &quot;body&quot;: &quot;...&quot;,         // Encrypted message body
}
</code></pre>
<p>These fields may be included as a sub-hash, or may be intermingled with other data fields. If you have doubts or concerns, please contact the Application Services team guidance</p>
<p>Based on the above payload, an example call might look like:</p>
<pre><code class="language-kotlin">    val result = manager.decrypt(
        channelID = payload[&quot;chid&quot;].toString(),
        body = payload[&quot;body&quot;].toString(),
        encoding = payload[&quot;con&quot;].toString(),
        salt = payload.getOrElse(&quot;enc&quot;, &quot;&quot;).toString(),
        dh = payload.getOrElse(&quot;dh&quot;, &quot;&quot;).toString()
    )
    // result returns a byte array. You may need to convert to a string
    return result.toString(Charset.forName(&quot;UTF-8&quot;))
</code></pre>
</div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.DispatchInfo.html" title="push::DispatchInfo struct">DispatchInfo</a></td><td class="docblock-short"><p>Dispatch Information returned from <a href="../push/struct.PushManager.html#method.dispatch_info_for_chid" title="PushManager::dispatch_info_for_chid"><code>PushManager::dispatch_info_for_chid</code></a></p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Error.html" title="push::Error struct">Error</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.FfiConverterTypeBridgeType.html" title="push::FfiConverterTypeBridgeType struct">FfiConverterTypeBridgeType</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.FfiConverterTypeDispatchInfo.html" title="push::FfiConverterTypeDispatchInfo struct">FfiConverterTypeDispatchInfo</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.FfiConverterTypeKeyInfo.html" title="push::FfiConverterTypeKeyInfo struct">FfiConverterTypeKeyInfo</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.FfiConverterTypePushError.html" title="push::FfiConverterTypePushError struct">FfiConverterTypePushError</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.FfiConverterTypePushSubscriptionChanged.html" title="push::FfiConverterTypePushSubscriptionChanged struct">FfiConverterTypePushSubscriptionChanged</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.FfiConverterTypeSubscriptionInfo.html" title="push::FfiConverterTypeSubscriptionInfo struct">FfiConverterTypeSubscriptionInfo</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.FfiConverterTypeSubscriptionResponse.html" title="push::FfiConverterTypeSubscriptionResponse struct">FfiConverterTypeSubscriptionResponse</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.InternalPushManager.html" title="push::InternalPushManager struct">InternalPushManager</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.KeyInfo.html" title="push::KeyInfo struct">KeyInfo</a></td><td class="docblock-short"><p>Key Information that can be used to encrypt payloads</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PushConfiguration.html" title="push::PushConfiguration struct">PushConfiguration</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.PushManager.html" title="push::PushManager struct">PushManager</a></td><td class="docblock-short"><p>Object representing the PushManager used to manage subscriptions</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PushSubscriptionChanged.html" title="push::PushSubscriptionChanged struct">PushSubscriptionChanged</a></td><td class="docblock-short"><p>An dictionary describing the push subscription that changed, the caller
will receive a list of <a href="../push/struct.PushSubscriptionChanged.html" title="PushSubscriptionChanged"><code>PushSubscriptionChanged</code></a> when calling
<a href="../push/struct.PushManager.html#method.verify_connection" title="PushManager::verify_connection"><code>PushManager::verify_connection</code></a>, one entry for each channel that the
caller should resubscribe to</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SubscriptionInfo.html" title="push::SubscriptionInfo struct">SubscriptionInfo</a></td><td class="docblock-short"><p>Subscription Information, the endpoint to send push messages to and
the key information that can be used to encrypt payloads</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SubscriptionResponse.html" title="push::SubscriptionResponse struct">SubscriptionResponse</a></td><td class="docblock-short"><p>The subscription response object returned from <a href="../push/struct.PushManager.html#method.subscribe" title="PushManager::subscribe"><code>PushManager::subscribe</code></a></p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.BridgeType.html" title="push::BridgeType enum">BridgeType</a></td><td class="docblock-short"><p>The types of supported native bridges.</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.ErrorKind.html" title="push::ErrorKind enum">ErrorKind</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="enum" href="enum.PushError.html" title="push::PushError enum">PushError</a></td><td class="docblock-short"><p>Public facing Error that the crate produces</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.Connection.html" title="push::Connection trait">Connection</a></td><td class="docblock-short"><p>A new communication link to the Autopush server</p>
</td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.get_random_bytes.html" title="push::get_random_bytes fn">get_random_bytes</a></td><td class="docblock-short"></td></tr></table><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<table><tr class="module-item"><td><a class="type" href="type.InternalResult.html" title="push::InternalResult type">InternalResult</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="type" href="type.Result.html" title="push::Result type">Result</a></td><td class="docblock-short"></td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="push" data-search-js="../search-index.js"></div>
    <script src="../main.js"></script></body></html>